---
title: "Cluster Analysis in Observe-ACS"
author: | 
        | christoph.reich@med.uni-heidelberg.de 
        | evangelos.giannitsis@med.uni-heidelberg.de
        | Klinik für Kardiologie, Angiologie und Pneumologie
        | Universitätsklinikum Heidelberg
        | 
date: "`r format(Sys.time(), '%d %B, %Y, %H:%M')`"
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_file = paste0(  
        Sys.Date(), '-',  "observeACS_analysis-clustering", '.html'
      ),
      output_dir = "./output-markdown",  
      envir = globalenv()
    )
  })
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    df_print: kable
---


```{r dependencies, include=FALSE}
# Set the working directory to the directory containing the R Markdown file
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

knitr::opts_chunk$set(echo = FALSE, 
                      fig.path = "../output-markdown/figures/",  # still a rmd relative file structure here
                      dev = "svg")


saveFILES <- FALSE

library(readxl)
library(dplyr)
library(tidyr)
library(tibble)
library(purrr)
library(ggplot2)
library(skimr)
library(tableone)
library(gt)
library(kableExtra)
library(Hmisc)
library(RColorBrewer)
library(survival)
library(survminer)
library(lubridate)  # datetimes
library(factoextra)  # plotting of kmeans


theme_set(ggthemes::theme_few()) 

# https://www.tidymodels.org/learn/statistics/k-means/
# This vignette would have been better .. 

  # ggthemes::theme_few()+
  # ggthemes::scale_colour_few()


# visualize results
# https://towardsdatascience.com/best-practices-for-visualizing-your-cluster-results-20a3baac7426
```


![AG Meder](../../img/meder_presentation_heart.png)


```{r load-dat}
base::source("./scripts/data_preprocessing.R")
#impdat.merged <- readRDS("./data/Rdata/impdat_merged_observe.rds") %>% as_tibble()

impdat.merged <- readRDS("./data/Rdata/2023-03-26-impdat_merged_observe.rds") %>% as_tibble()  # updated to add "V_t0_hstnt_value"
```


# Cluster Analysis


## Hierarchical Clustering

```{r hierarchical-clustering, fig.height=10, fig.width=70}
# Finding distance matrix
distance_mat <- dist(impdat.merged %>% select(-V_rapID), method = 'euclidean')

# Fitting Hierarchical clustering Model to training dataset
set.seed(240)  # Setting seed
Hierar_cl <- hclust(distance_mat, method = "average")
Hierar_cl

# Plotting dendrogram
plot(Hierar_cl)
```

## K-means-clustering

```{r k-means-clustering}
set.seed(123)
x<- scale(impdat.merged %>% 
            select(-V_rapID) %>% 
            mutate(V_h_lvdys_grad = as.numeric(V_h_lvdys_grad))
)

fviz_nbclust(x, FUNcluster=kmeans, method = "wss") +
  geom_vline(xintercept = 6, linetype = 2)
```


```{r k-means-clustering-for-all-6-clusterings, figures-side, fig.show='hold', out.width="50%"}
set.seed(123)

dat.with.clusters <- impdat.merged

centroids<- 6
for(i in 2:centroids) {  # create 2 to 6 clusters
  title_plot <- paste("k = ", i)
  kmeans_loop <- kmeans(x, centers = i, iter.max = 1000, nstart = 25)
  
  ### name clusters
  ordered.index <- order(table(kmeans_loop$cluster), decreasing=TRUE)
  for (j in 1:max(kmeans_loop$cluster)) {
    cluster.name <- paste("Cluster ", j, sep = "")
    #kmeans$cluster[kmeans$cluster == ordered.index[1]] <- "No CAD"
    kmeans_loop$cluster[kmeans_loop$cluster == ordered.index[j]] <- cluster.name
  }
  
  colname_cluster_n <- paste0("clusters_", i)
  dat.with.clusters <- dat.with.clusters %>% 
    mutate(!! colname_cluster_n := kmeans_loop$cluster)
  
  # plot clusters
  print(fviz_cluster(object = kmeans_loop, data = impdat.merged %>% 
                       mutate(V_h_lvdys_grad = as.numeric(V_h_lvdys_grad)),
                     geom = "point", 
                     #ellipse.type = "euclid",
                     alpha =0.5,
                     shape = 16,
                     show.legend=FALSE) +
          ggtitle(title_plot)+
          ggthemes::theme_few()+
          ggthemes::scale_color_few()+
          theme(legend.title=element_blank())
  )
}

# aggregate(impdat.merged, by=list(cluster=dat.with.clusters$clusters_5), mean)
```


## K-prototypes-clustering

K-Prototypes is an extension of the K-Means algorithm and is specifically designed to handle mixed data types (continuous and categorical). It combines the K-Means algorithm (used for continuous variables) and the K-Modes algorithm (used for categorical variables) by minimizing the sum of the distances within each cluster for both continuous and categorical attributes.

The K-Prototypes algorithm calculates the distance between data points using a combined distance measure, which takes into account both the Euclidean distance (for continuous variables) and the Hamming distance (for categorical variables). The algorithm iteratively refines the cluster centroids and reassigns the data points to clusters until convergence is achieved.


```{r prototype-clust-dat}
# https://towardsdatascience.com/the-k-prototype-as-clustering-algorithm-for-mixed-data-type-categorical-and-numerical-fe7c50538ebb
# https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.15.4028&rep=rep1&type=pdf
library(clustMixType)
set.seed(202304)
fctrs.prototypes <- 
           c("V_sex_f1_m0", "V_symptombeginn", "V_symptom_thoraxschmerz", "V_symptomtyp", "V_h_infarkt", "V_h_khk",
             "KHK__Killip_Class",
           "V_ekg_t_negativierung","V_ekg_schrittmacher", "V_ekg_atriale_tachy", "V_ekg_block_ohne_sm", 
           "V_ekg_st_senkung", "V_ekg_sinusrhythmus" ,"V_ekg_sinus_normal",
           "V_h_diabetes", "V_h_hypertonie", "V_h_cholesterin","V_aktiver_raucher", 
           "V_h_familienana", "V_h_cabg", "V_h_vessel_disease", "V_h_pci", "V_h_lvdys_grad")

# prepare dat
x.prototypes <- impdat.merged %>% 
  select(-V_rapID) %>% 
  mutate(across(fctrs.prototypes, as.factor)) %>% 
  mutate(across(c(!fctrs.prototypes), ~scale(.x, center = TRUE, scale = TRUE)))

# Check for the optimal number of clusters given the data
wss<-vector()
for (i in 2:10){ wss[i] <- sum(kproto(x.prototypes, i, verbose = FALSE)$withinss)}
par(mfrow=c(1,1))
plot(1:10, wss, type="b", xlab="Number of Clusters",
     ylab="Within groups sum of squares",
     main="Assessing the Optimal Number of Clusters with the Elbow Method",
     pch=20, cex=2)
```

```{r run-k-prototype}
# Set the number of clusters
num_clusters <- 3

# Run K-Prototypes clustering
kproto_result <- kproto(x.prototypes, num_clusters, verbose = FALSE, )

# Perform PCA on continuous variables
continuous_vars <- x.prototypes[, sapply(x.prototypes, is.numeric)]
pca_result <- prcomp(continuous_vars, scale. = TRUE)

# Create a data frame with the first two PCA components
pca_df <- data.frame(pca_result$x[, 1:2])
colnames(pca_df) <- c("PC1", "PC2")

# Add cluster assignments to the PCA data frame:
pca_df$cluster <- as.factor(kproto_result$cluster)

# Create the cluster plot
fviz_cluster(list(data = pca_df[1:2], cluster = kproto_result$cluster),
             geom = "point",
             alpha=0.5,
             shape=16,
             show.legend=FALSE,
             repel = TRUE,
             show.clust.cent = FALSE) +
  ggtitle("title")+
  ggthemes::theme_few()+
  ggthemes::scale_color_few()+
  theme(legend.title = element_blank()) -> testplot
```

```{r k-prototypes-loop, figures-side, fig.show='hold', out.width="50%"}

set.seed(123)
centroids <- 6
lambda_values <- seq(0.1, 1, by = 0.1)

# Perform PCA on continuous variables (plot numeric grid)
continuous_vars <- x.prototypes[, sapply(x.prototypes, is.numeric)]
pca_result <- prcomp(continuous_vars, scale. = TRUE)

# Create a data frame with the first two PCA components
pca_df <- data.frame(pca_result$x[, 1:2])
colnames(pca_df) <- c("PC1", "PC2")
  
for(i in 2:centroids) {  # create 2 to 6 clusters
  
  # Initialize variables to store the results (tune lambda:  balance the importance of continuous and categorical variables)
  best_lambda <- NULL
  lowest_cost <- Inf
  
  # Run K-Prototypes clustering for each lambda value
  for (lambda in lambda_values) {
    kproto_result <- kproto(x= x.prototypes, k = i, lambda = lambda, verbose = FALSE)
    
    # Compare the total cost and update the best lambda value if necessary
    if (kproto_result$tot.withinss < lowest_cost) {
      lowest_cost <- kproto_result$tot.withinss
      best_lambda <- lambda
    }
  }
  
  ### name clusters
  ordered.index <- order(table(kproto_result$cluster), decreasing=TRUE)
  for (j in 1:max(kproto_result$cluster)) {
    cluster.name <- paste("Cluster ", j, sep = "")
    #kmeans$cluster[kmeans$cluster == ordered.index[1]] <- "No CAD"
    kproto_result$cluster[kproto_result$cluster == ordered.index[j]] <- cluster.name
  }
  
  colname_cluster_n <- paste0("clusters_kprototype", i)
  dat.with.clusters <- dat.with.clusters %>% 
    mutate(!! colname_cluster_n := kproto_result$cluster)
  
  # PLOT
  title_plot <- paste("k-Prototypes Clustering with k = ", i)
  subtitle_plot <- bquote("Tuned " ~ lambda ~  ": " ~.(best_lambda))   # terms wrapped in .() are evaluated 
  # Add cluster assignments to the PCA data frame:
  pca_df$cluster <- as.factor(kproto_result$cluster)
  
  # Create the cluster plot
  plot(fviz_cluster(list(data = pca_df[1:2], cluster = kproto_result$cluster),
               geom = "point",
               alpha=0.5,
               shape=16,
               show.legend=FALSE,
               repel = TRUE,
               show.clust.cent = FALSE) +
    labs(title = title_plot, subtitle = subtitle_plot)+
    ggthemes::theme_few()+
    ggthemes::scale_color_few()+
    theme(legend.title = element_blank())
  )
}
```

## DBSCAN

DBSCAN (Density-Based Spatial Clustering of Applications with Noise) is a density-based clustering algorithm that can handle noise and outliers. DBSCAN is not specifically designed for mixed data types (continuous and categorical). Nonetheless, we can use a distance metric that can handle mixed data types and apply the DBSCAN algorithm using the fpc package in R.

A popular distance metric for mixed data types is the Gower distance. We can calculate the Gower distance using the cluster package and then apply DBSCAN using the fpc package.

```{r}
library(cluster)
library(fpc)
library(dbscan)
set.seed(202304)

dbscan.dat <- impdat.merged %>% select(-1)

# define factors
index <- which(colnames(dbscan.dat) %in% fctrs.prototypes)
dbscan.dat[index] <- lapply(dbscan.dat[index], as.factor)


## daisy | Dissimilarity Matrix Calculation -----------------------------------
gower_dist <- daisy(dbscan.dat, metric = "gower", type = list("factor" = index))


# Choose a range of values for eps and MinPts to be tuned:  -------------------
eps_values <- seq(0.1, 0.9, by = 0.1)
minPts_values <- 5:10

# Initialize variables to store the best parameters and the highest silhouette score
best_eps <- 0
best_minPts <- 0
best_avg_sil <- -1

# TUNE | Loop through all combinations of eps and MinPts ----------------------
for (eps in eps_values) {
  for (minPts in minPts_values) {
    # Perform DBSCAN clustering using the Gower distance
    dbscan_result <- fpc::dbscan(gower_dist, eps = eps, MinPts = minPts, method = "dist")
    
    # Check if there are clusters in the results
    if (length(unique(dbscan_result$cluster)) > 1) {
      # Calculate the average silhouette score for the current combination of parameters
      avg_sil <- suppressWarnings(cluster.stats(gower_dist, dbscan_result$cluster)$avg.silwidth)  # some of the clusters have no points assigned to them
      
      # Update the best parameters if the current average silhouette score is higher
      if (avg_sil > best_avg_sil) {
        best_avg_sil <- avg_sil
        best_eps <- eps
        best_minPts <- minPts
      }
    }
  }
}

# Apply DBSCAN clustering with the best combination of eps and MinPts ---------
dbscan_result <- fpc::dbscan(gower_dist, eps = best_eps, MinPts = best_minPts, method = "dist")

# Print the best parameters and the highest silhouette score
cat("Best eps:", best_eps, "\n")
cat("Best MinPts:", best_minPts, "\n")
cat("Highest average silhouette score:", best_avg_sil, "\n")

# Print the clustering results
print(dbscan_result)
# Plot the clustering results (using the first two principal components) here uses "dc" discriminant coordinates
plotcluster(gower_dist, dbscan_result$cluster)  # must be before renaming (boolean clusters needed)  ;)


### name clusters
dbscan_result$cluster <- dbscan_result$cluster + 1   # instead of 0,1, ... start with 1,2,..

ordered.index <- order(table(dbscan_result$cluster), decreasing=TRUE)
for (j in seq_along(ordered.index)) {
  cluster.name <- paste("Cluster ", j, sep = "")
  #kmeans$cluster[kmeans$cluster == ordered.index[1]] <- "No CAD"
  dbscan_result$cluster[dbscan_result$cluster == ordered.index[j]] <- cluster.name
}

dat.with.clusters <- dat.with.clusters %>% 
  mutate(clusters_dbscan = dbscan_result$cluster)


# plot DBSCAN against PC1 and PC2 #----------------------------------------------------
plot(fviz_cluster(list(data = pca_df[1:2], cluster = dbscan_result$cluster),
               geom = "point",
               alpha=0.5,
               shape=16,
               show.legend=FALSE,
               repel = TRUE,
               show.clust.cent = FALSE) +
    labs(title = "DBSCAN", subtitle = paste0("Best eps: ", best_eps, "; Best MinPts: ", best_minPts))+
    ggthemes::theme_few()+
    ggthemes::scale_color_few()+
    theme(legend.title = element_blank()))

# manual ggplot
pca_df$dbscan_cluster <- as.factor(dbscan_result$cluster)
ggplot(pca_df, aes(x = PC1, y = PC2, colour = dbscan_cluster)) +
  geom_point(alpha=0.5) +
  labs(title = "DBSCAN Clustering Results",
       x = "Principal Component 1",
       y = "Principal Component 2",
       color = "Cluster") +
  ggthemes::theme_few()+
  ggthemes::scale_colour_few() -> gg_pca_cluster_dbscan
```


\clearpage


## Survival Analysis

```{r}
surv.dat <- dat.with.clusters %>% 
  #dplyr::left_join(dat.observe %>% select(-V_h_lvdys_grad)) %>% 
  #dplyr::bind_cols(dat.observe %>% select(-V_rapID)) %>% 
  #relocate(V_rapID, .before = V_h_diabetes) %>% 
  bind_cols(dat.outcome)

# fctrs <- c("V_h_diabetes", "V_h_hypertonie", "V_h_cholesterin","V_aktiver_raucher", 
#            "V_h_familienana", "V_h_cabg", "V_h_vessel_disease", "V_h_pci", "V_h_lvdys_grad",
#            "V_o_mortality")

surv.dat1 <- surv.dat %>% 
  rename(Age = V_age, Sex = V_sex_f1_m0, Symptom_Onset = V_symptombeginn, Type_Chest_Pain = V_symptom_thoraxschmerz,
         Type_Symptom = V_symptomtyp, History_MI = V_h_infarkt, History_CAD = V_h_khk, ECG_T_Neg = V_ekg_t_negativierung, 
         ECG_Pacemaker = V_ekg_schrittmacher, ECG_Atrial_Tachycardia = V_ekg_atriale_tachy, ECG_BBB = V_ekg_block_ohne_sm,
         ECG_ST_Depression = V_ekg_st_senkung, ECG_Sinusrhythm = V_ekg_sinusrhythmus, ECG_normal = V_ekg_sinus_normal,
         Killip_Class = KHK__Killip_Class, 
         # history
         Diabetes_mellitus = V_h_diabetes, Hypertension = V_h_hypertonie, Hypercholesterolemia =V_h_cholesterin, 
         Smoker = V_aktiver_raucher, HistoryCAD_Family = V_h_familienana, History_CABG =V_h_cabg, 
         History_vessel_disease = V_h_vessel_disease,
         History_PCI = V_h_pci, 
         ## vitals
         LV_dysfunction = V_h_lvdys_grad, RR_diastolic = V_vit_rr_diast, RR_systolic = V_vit_rr_syst,
         Heart_Rate = V_vit_herzfrequenz,  Temperature = V_vit_temperatur, spO2=V_vit_saettigung, BreathingRate =V_vit_atemfrequenz,
         ## labs
         hsTrop = V_t0_hstnt_value, hsTrop_delta = V_delta_c_first_tnt_relativ, 
         CKD_EPI = V_t0_ckdepi_value, Creatinine = V_t0_krea_value, CRP = V_t0_crp_value, Leucocytes = V_t0_leuko_value,
         Urea = V_t0_hst_value, Sodium= V_t0_na_value, Potassium =V_t0_k_value,
         Glucose =V_t0_gluc_value, CK =V_t0_ck_value, LDH=V_t0_ldh_value, GOT=V_t0_got_value, GPT=V_t0_gpt_value,
         Hemoglobine =V_t0_hb_value, HKT = V_t0_hkt_value, MCV=V_t0_mcv_value, MCH= V_t0_mch_value, MCHC =V_t0_mchc_value,
         Thrombocytes=V_t0_thrombo_value, Quick=V_t0_quick_value, INR =V_t0_inr_value, GRACE_Score =V_grace_score, 
         # outcomes
         AC_mortaliy = V_o_mortality) %>% 
  relocate(hsTrop:hsTrop_delta, .after = BreathingRate) %>% 
  relocate(ECG_T_Neg:ECG_normal, .after = BreathingRate) %>% 
  relocate(GRACE_Score, .before=Killip_Class)
  

fctrs1 <- c("Sex", "Symptom_Onset",  "Type_Chest_Pain", "Type_Symptom", "History_MI", "History_CAD", "ECG_T_Neg", "ECG_Pacemaker", 
"ECG_Atrial_Tachycardia", "ECG_BBB", "ECG_ST_Depression", "ECG_Sinusrhythm", "ECG_normal", "Killip_Class", "Diabetes_mellitus", 
"Hypertension", "Hypercholesterolemia", "Smoker", "HistoryCAD_Family", 
"History_CABG", "History_vessel_disease", "History_PCI", "LV_dysfunction", "AC_mortaliy")


fctrs <- c("V_sex_f1_m0", "V_symptombeginn", "V_symptom_thoraxschmerz", "V_symptomtyp", "V_h_infarkt", "V_h_khk",
           "KHK__Killip_Class",
           "V_ekg_t_negativierung","V_ekg_schrittmacher", "V_ekg_atriale_tachy", "V_ekg_block_ohne_sm", 
           "V_ekg_st_senkung", "V_ekg_sinusrhythmus" ,"V_ekg_sinus_normal",
           "V_h_diabetes", "V_h_hypertonie", "V_h_cholesterin","V_aktiver_raucher", 
           "V_h_familienana", "V_h_cabg", "V_h_vessel_disease", "V_h_pci", "V_h_lvdys_grad",
           "V_o_mortality")
           #"clusters_2", "clusters_3", "clusters_4", "clusters_5", "clusters_6", 
           #"clusters_kprototype2", "clusters_kprototype3", "clusters_kprototype4", "clusters_kprototype5", "clusters_kprototype6",
           #"clusters_dbscan")

allvars <- c("V_h_diabetes", "V_h_hypertonie", "V_h_cholesterin","V_aktiver_raucher", 
           "V_h_familienana", "V_h_cabg", "V_h_vessel_disease", "V_h_pci", "V_h_lvdys_grad",
           "V_vit_rr_diast" , "V_vit_rr_syst","V_vit_herzfrequenz","V_vit_temperatur" ,"V_vit_saettigung",
           "V_vit_atemfrequenz", "V_t0_ckdepi_value", "V_t0_krea_value","V_t0_crp_value","V_t0_leuko_value",
           "V_t0_hst_value", "V_t0_na_value", "V_t0_k_value", "V_t0_gluc_value",  "V_t0_ck_value",
           "V_t0_ldh_value", "V_t0_got_value", "V_t0_gpt_value", "V_t0_hb_value", "V_t0_hkt_value",
           "V_t0_mcv_value", "V_t0_mch_value", "V_t0_mchc_value","V_t0_thrombo_value","V_t0_quick_value",
           "V_t0_inr_value", "V_grace_score",
           "V_o_time_mortality", "V_o_mortality" )

# convert to factor
surv.dat[fctrs] <- lapply(surv.dat[fctrs], factor)
surv.dat1[fctrs1] <- lapply(surv.dat1[fctrs1], factor)

surv.dat <- surv.dat %>% 
  # encode factors
  mutate_at(.vars = fctrs, .funs = factor)
```


### Table 01

We can get a better overview by creating a *TableOne*. 

```{r tableone, echo=FALSE}
t1 <- tableone::CreateTableOne(data=surv.dat1 %>% select(-1, 
                                                        -c(55:65),   # clusters
                                                        -c(66:69),   # outcomes except overall mortality
                                                        -c(71:82)),  # outcomes
                               factorVars = fctrs1[-c(24:34)])
tableone::kableone(t1) %>% 
  pack_rows(group_label = "Number of Patients", start_row = 1, end_row = 1) %>% 
  pack_rows(group_label = "Demographics", start_row = 2, end_row = 3) %>% 
  pack_rows(group_label = "History and Symptoms", start_row = 4, end_row = 33) %>% 
  pack_rows(group_label = "Echo and Vital Signs", start_row = 34, end_row = 44) %>% 
  pack_rows(group_label = "ECG", start_row = 45, end_row = 51) %>% 
  pack_rows(group_label = "Lab", start_row = 52, end_row = 73) %>% 
  pack_rows(group_label = "Primary Outcome", start_row = 74, end_row = 74) %>% 
  kable_classic(full_width = T)
```

## Stratum k-means

### k-means 2 centroids

```{r tableone-strat-kmeans2, echo=FALSE}
t2.cluster2 <- CreateTableOne(data=surv.dat1 %>% select(-1,   # "V_rapID" 
                                              #
                                              -c(56:69),  # other clusters and outcomes until overall mortality
                                              -c(71:82)), # all other outcomes
                     strata = "clusters_2", 
                     #vars = colnames(surv.dat)[-c(4,5,15,16)],
                     factorVars = fctrs1)

tableone::kableone(t2.cluster2, test=TRUE) %>% 
  pack_rows(group_label = "Number of Patients", start_row = 1, end_row = 1) %>% 
  pack_rows(group_label = "Demographics", start_row = 2, end_row = 3) %>% 
  pack_rows(group_label = "History and Symptoms", start_row = 4, end_row = 33) %>% 
  pack_rows(group_label = "Echo and Vital Signs", start_row = 34, end_row = 44) %>% 
  pack_rows(group_label = "ECG", start_row = 45, end_row = 51) %>% 
  pack_rows(group_label = "Lab", start_row = 52, end_row = 73) %>% 
  pack_rows(group_label = "Clusters", start_row = 74, end_row = 74) %>% 
  pack_rows(group_label = "Primary Outcome", start_row = 75, end_row = 75) %>% 
  kable_classic(full_width = T)
```


```{r radar-plot}
library(fmsb)

## CREATE MAXMIN DF -----------------------------------------------------------
max_min <- tibble(
  Row_index = c("Max", "Min"),
  Age = c(85,40), #c(max(surv.dat1$Age), min(surv.dat1$Age)),
  Sex = c(1,0),
  ECG_normal = c(1,0),
  Heart_Rate = c(100,50), #c(max(surv.dat1$Heart_Rate), min(surv.dat1$Heart_Rate)),
  LV_dysfunction = c(1,0),
  # lab
  hsTrop = c(30,10), #c(max(surv.dat1$hsTrop), min(surv.dat1$hsTrop)),
  CRP = c(30,5), # one cluster has 130!!,  c(max(surv.dat1$CRP), min(surv.dat1$CRP)),
  Creatinine = c(1.8, 0.8), #c(max(surv.dat1$Creatinine), min(surv.dat1$Creatinine)),
  Hemoglobine = c(15,11), #c(max(surv.dat1$Hemoglobine), min(surv.dat1$Hemoglobine)),
)

## PREPARE AVERAGE ALL DAT --------------------------------------------------
radar_plot_average_all <- surv.dat1 %>% 
  select( 
         # demographics
         Age, Sex, 
         # ECG & Vitals
         ECG_normal, Heart_Rate, LV_dysfunction,
         # labs
         hsTrop, CRP, Creatinine, Hemoglobine) %>% 
  summarise( 
            Age = mean(Age), Sex = sum(Sex == "0")/n(),   # cave factors 0==1 , and 1==2
            ECG_normal=sum(ECG_normal==1)/n(), Heart_Rate=mean(Heart_Rate), LV_dysfunction = sum(LV_dysfunction=="good")/n(),
            hsTrop= mean(hsTrop), CRP=mean(CRP), Creatinine=mean(Creatinine), Hemoglobine=mean(Hemoglobine)
  ) %>% 
  mutate(Row_index = "Average_profile")



# ex prep dat
radar_plot_dat_prep <- surv.dat1 %>% 
  select(clusters_2, 
         # demographics
         Age, Sex, 
         # ECG & Vitals
         ECG_normal, Heart_Rate, LV_dysfunction,
         # labs
         hsTrop, CRP, Creatinine, Hemoglobine) %>% 
  group_by(clusters_2) %>% 
  summarise(n=n(), 
            Age = mean(Age), Sex = sum(Sex == "0")/n,   # cave factors 0==1 , and 1==2
            ECG_normal=sum(ECG_normal==1)/n, Heart_Rate=mean(Heart_Rate), LV_dysfunction = sum(LV_dysfunction=="good")/n,
            hsTrop= mean(hsTrop), CRP=mean(CRP), Creatinine=mean(Creatinine), Hemoglobine=mean(Hemoglobine)
  ) %>% 
  mutate(Row_index = levels(factor(clusters_2))) %>% 
  select(-c(clusters_2, n))


radar_plot_dat <- rbind(max_min, radar_plot_dat_prep) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

# basic radar plot
cluster1_data <- radar_plot_dat[c("Max", "Min", "Cluster 1"), ]
# radarchart(cluster1_data)
```




```{r radarplot-helper-fns}
# PREPARE PLOT DATA ------------------------------------------------------------

prepare_radar_plot_dat <- function(data, cluster_var) {
  radar_plot_dat_prep <- data %>% 
    select({{cluster_var}}, 
           # demographics
           Age, Sex, 
           # ECG & Vitals
           ECG_normal, Heart_Rate, LV_dysfunction,
           # labs
           hsTrop, CRP, Creatinine, Hemoglobine) %>% 
    group_by(eval(as.symbol(cluster_var))) %>%  # group_by({{cluster_var}})   does not work
    summarise(#n=n(), 
              Age = mean(Age), Sex = sum(Sex == "0")/n(),   
              ECG_normal=sum(ECG_normal==1)/n(), Heart_Rate=mean(Heart_Rate), LV_dysfunction = sum(LV_dysfunction=="good")/n(),
              hsTrop= mean(hsTrop), CRP=mean(CRP), Creatinine=mean(Creatinine), Hemoglobine=mean(Hemoglobine)
    ) %>%    
    rename(Row_index=`eval(as.symbol(cluster_var))`) 
  
  return(radar_plot_dat_prep)
}

# run function example
radar_plot_dat <- rbind(max_min, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_3")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)
# basic radar plot
cluster1_data <- radar_plot_dat[c("Max", "Min", "Cluster 1"), ]
#radarchart(cluster1_data)


# BEAUTIFUL PLOT ------------------------------------------------------------
# https://www.datanovia.com/en/blog/beautiful-radar-chart-in-r-using-fmsb-and-ggplot-packages/
create_beautiful_radarchart <- function(data, color = "#00AFBB", 
                                        vlabels = colnames(data), vlcex = 0.7,
                                        caxislabels = NULL, title = NULL, ...){
  radarchart(
    data, axistype = 1,
    # Customize the polygon
    pcol = color, pfcol = scales::alpha(color, 0.3), plwd = 2, plty = 1,
    # Customize the grid
    cglcol = "grey", cglty = 1, cglwd = 0.8,
    # Customize the axis
    axislabcol = "grey", 
    # Variable labels
    vlcex = vlcex, vlabels = vlabels,
    caxislabels = caxislabels, title = title, ...
  )
}
# Reduce plot margin using par()
#op <- par(mar = c(1, 2, 2, 1))
#create_beautiful_radarchart(cluster1_data, caxislabels = c("min", "", "", "", "max"))

#par(op)
```


```{r radarplot-multiple-at-once}
# Reduce plot margin using par()
# op <- par(mar = c(1, 2, 2, 2))
# # Create the radar charts
# create_beautiful_radarchart(
#   data = radar_plot_dat, caxislabels = c("min", "", "", "", "max"),
#   color = c("#00AFBB", "#E7B800", "#FC4E07")
# )
# # Add an horizontal legend
# legend(
#   x = "bottom", legend = rownames(radar_plot_dat[-c(1,2),]), horiz = TRUE,
#   bty = "n", pch = 20 , col = c("#00AFBB", "#E7B800", "#FC4E07"),
#   text.col = "black", cex = 1, pt.cex = 1.5
#   )
```

```{r radarplot-multiple-at-once-facetted}
# Define colors and titles
colors <- c("#00AFBB", "#E7B800", "#FC4E07")
titles <- rownames(radar_plot_dat[-c(1,2),])

# Reduce plot margin using par()
# Split the screen in 3 parts
# op <- par(mar = c(1, 1, 1, 1))
# par(mfrow = c(1,length(titles)))
# 
# # Create the radar chart
# for(i in 1:length(titles)){
#   create_beautiful_radarchart(
#     data = radar_plot_dat[c(1, 2, i+2), ], caxislabels = c("min", "", "", "", "max"),
#     color = colors[i], title = titles[i]
#     )
# }
# par(op)
```


```{r compare-every-profile-to-average}
## 1. Create data containing all clusters and average profile
set.seed(123)
radar_plot_dat <- rbind(radar_plot_average_all, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_3")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

## 2. Rescale each variable to range between 0 and 1
library(scales)
df_scaled <- round(apply(radar_plot_dat, 2, scales::rescale), 2)
df_scaled <- as.data.frame(df_scaled)
# head(df_scaled)

## 3. Prepare the data for creating the radar plot using the fmsb package:
# Variables summary
# Get the minimum and the max of every column  
col_max <- apply(df_scaled, 2, max)
col_min <- apply(df_scaled, 2, min)
# Calculate the average profile 
## col_mean <- apply(df_scaled, 2, mean)

# Put together the summary of columns
col_summary <- t(data.frame(Max = col_max, Min = col_min)) #, Average = col_mean))


# Bind variables summary to the data
df_scaled2 <- as.data.frame(rbind(col_summary, df_scaled))
# head(df_scaled2)

# ## 4. Produce radar plots showing both the average profile and the individual profile:
# opar <- par() 
# # Define settings for plotting in a 3x4 grid, with appropriate margins:
# par(mar = rep(0.8,4))
# par(mfrow = c(3,4))
# # Produce a radar-chart for each student
# for (i in 4:nrow(df_scaled2)) {
#   radarchart(
#     df_scaled2[c(1:3, i), ],
#     pfcol = c("#99999980",NA),
#     pcol= c(NA,2), plty = 1, plwd = 2,
#     title = row.names(df_scaled2)[i]
#   )
# }
# # Restore the standard par() settings
# par <- par(opar) 

```


```{r function-for-radar-plots-with-average}
create_radar_plot <- function(radar_plot_dat) {
  # Load necessary libraries
  library(scales)
  library(fmsb)
  
  radar_plot_dat <- radar_plot_dat %>% 
    rename("Normal ECG" = ECG_normal, "Heart Rate"= Heart_Rate, "Normal LV-F" = LV_dysfunction)

  # Rescale each variable to range between 0 and 1
  df_scaled <- round(apply(radar_plot_dat, 2, scales::rescale), 2)
  df_scaled <- as.data.frame(df_scaled)

  # Prepare the data for creating the radar plot using the fmsb package
  col_max <- apply(df_scaled, 2, max)
  col_min <- apply(df_scaled, 2, min)
  col_summary <- t(data.frame(Max = col_max, Min = col_min))
  df_scaled2 <- as.data.frame(rbind(col_summary, df_scaled))

  # Produce radar plots showing both the average profile and the individual profile
  opar <- par()
  par(mar = rep(0.8, 4))
  par(mfrow = c(3, 4))

  for (i in 4:nrow(df_scaled2)) {
    radarchart(
      df_scaled2[c(1:3, i), ],
      pfcol = c("#99999980", NA),
      pcol = c(NA, 2), plty = 1, plwd = 2,
      title = row.names(df_scaled2)[i]
    )
  }

  # Restore the standard par() settings
  par(opar)
}

    

#create_radar_plot(radar_plot_dat)
```




### k-means 3 centroids

```{r tableone-strat-kmeans3, echo=FALSE}
t2 <- CreateTableOne(data=surv.dat1 %>% select(-1,   # "V_rapID" 
                                              -55,  # clusters_2
                                              -c(57:69),  # other clusters and outcomes until overall mortality
                                              -c(71:82)), # all other outcomes
                     strata = "clusters_3", 
                     #vars = colnames(surv.dat)[-c(4,5,15,16)],
                     factorVars = fctrs1)
tableone::kableone(t2, test=TRUE) %>% 
  pack_rows(group_label = "Number of Patients", start_row = 1, end_row = 1) %>% 
  pack_rows(group_label = "Demographics", start_row = 2, end_row = 3) %>% 
  pack_rows(group_label = "History and Symptoms", start_row = 4, end_row = 33) %>% 
  pack_rows(group_label = "Echo and Vital Signs", start_row = 34, end_row = 44) %>% 
  pack_rows(group_label = "ECG", start_row = 45, end_row = 51) %>% 
  pack_rows(group_label = "Lab", start_row = 52, end_row = 73) %>% 
  pack_rows(group_label = "Clusters", start_row = 74, end_row = 77) %>% 
  pack_rows(group_label = "Primary Outcome", start_row = 78, end_row = 78) %>% 
  kable_classic(full_width = T)
```



### k-means 4 centroids

```{r tableone-strat-kmeans4, echo=FALSE}
t4 <- CreateTableOne(data=surv.dat1 %>% select(-1,   # "V_rapID" 
                                              -c(55:56),  # clusters_2
                                              -c(58:69),  # other clusters and outcomes until overall mortality
                                              -c(71:82)), # all other outcomes
                     strata = "clusters_4", 
                     #vars = colnames(surv.dat)[-c(4,5,15,16)],
                     factorVars = fctrs1)
tableone::kableone(t4, test=TRUE) %>% 
  pack_rows(group_label = "Number of Patients", start_row = 1, end_row = 1) %>% 
  pack_rows(group_label = "Demographics", start_row = 2, end_row = 3) %>% 
  pack_rows(group_label = "History and Symptoms", start_row = 4, end_row = 33) %>% 
  pack_rows(group_label = "Echo and Vital Signs", start_row = 34, end_row = 44) %>% 
  pack_rows(group_label = "ECG", start_row = 45, end_row = 51) %>% 
  pack_rows(group_label = "Lab", start_row = 52, end_row = 73) %>% 
  pack_rows(group_label = "Clusters", start_row = 74, end_row = 78) %>% 
  pack_rows(group_label = "Primary Outcome", start_row = 79, end_row = 79) %>% 
  kable_classic(full_width = T)
```



### KM curves with Radar Plots

```{r surv-analysis-data-os-descriptive, figures-side, fig.show='hold', out.width="33%"}
surv.dat.km <- surv.dat %>% 
  drop_na(V_o_time_mortality) %>% 
  mutate(V_o_time_mortality = V_o_time_mortality/360) %>% 
  mutate(V_o_mortality = as.numeric(V_o_mortality))

f1 <- survfit(Surv(V_o_time_mortality, V_o_mortality) ~ 1, data =surv.dat.km)

# plot(survfit(Surv(V_o_time_mortality, V_o_mortality) ~ 1, data = surv.dat.km), 
#      xlab = "Years", 
#      ylab = "Overall survival probability")

tidy_surv <- broom::tidy(f1)
niceggplot <- ggplot(tidy_surv, aes(time, estimate))+
  geom_line()+
  geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha=.25)

fast_plot <- ggsurvplot(
  fit = f1, data = surv.dat.km,
  xlab = "Years", 
  ylab = "Overall survival probability")
```


```{r surv-analysis-plot-kmeans, figures-side, fig.show='hold', out.width="100%", warning=FALSE, message=FALSE}
# reorder factors with levels / not labels!!
#surv.dat["kmeans3centers"] <- factor(surv.dat$kmeans3centers, levels = c("No CAD", "Cluster 2", "Cluster 3")) #, labels=c("No CAD", "Cluster 2", "Cluster 3"))
#surv.dat["kmeans3to2centers"] <- factor(surv.dat$kmeans3to2centers, levels = c("No CAD", "Cluster 2"))
#surv.dat["kmeans6to2centers"] <- factor(surv.dat$kmeans6to2centers, levels = c("No CAD", "Cluster 2"))

source("./scripts/helper/ggsurvplot_custom.R")

## surv curves
easyplot <- ggsurvplot(
  fit = survfit(Surv(V_o_time_mortality, V_o_mortality)~clusters_3, data = surv.dat.km),
  xlab = "Years", 
  ylab = "Overall survival probability",
  title="Kaplan Meier",
  subtitle ="Stratified by 3 centroids",
  legend.title="",
  legend.labs = c("Cluster 1", "Cluster 2", "Cluster 3"),
  pval = TRUE, risk.table = TRUE) 

ggsurv2 <- ggsurvplot_custom(fit_object = survfit(Surv(V_o_time_mortality, V_o_mortality)~clusters_2, data = surv.dat.km), mytitle = "Cluster Analysis - 2 unsupervised clusters", legend.title = "Clusters", myXbreaks = c(1,2), legend.labs = c("Cluster 1", "Cluster 2"), plot_inlay = TRUE,  save=FALSE)

ggsurv3 <- ggsurvplot_custom(fit_object = survfit(Surv(V_o_time_mortality, V_o_mortality)~clusters_3, data = surv.dat.km), mytitle = "Cluster Analysis - 3 unsupervised clusters", legend.title = "Clusters", myXbreaks = c(1,2), legend.labs = c("Cluster 1", "Cluster 2", "Cluster 3" ), plot_inlay = TRUE,  save=FALSE)

ggsurv4 <- ggsurvplot_custom(fit_object = survfit(Surv(V_o_time_mortality, V_o_mortality)~clusters_4, data = surv.dat.km), mytitle = "Cluster Analysis - 4 unsupervised clusters", legend.title = "Clusters", myXbreaks = c(1,2), legend.labs = c("Cluster 1", "Cluster 2", "Cluster 3", "Cluster 4" ), plot_inlay = TRUE,  save=FALSE)

# ggsurv2
# ggsurv3
# ggsurv4
```

```{r surv-analysis-plot-kmeans-with-radar, figures-side, fig.show='hold', out.width="100%", warning=FALSE, message=FALSE}
# Function and Test in Chapter k-means 2 centroids

## 2 clusters
ggsurv2
radar_plot_dat <- rbind(radar_plot_average_all, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_2")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

create_radar_plot(radar_plot_dat)


## 3 clusters
ggsurv3
radar_plot_dat <- rbind(radar_plot_average_all, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_3")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

create_radar_plot(radar_plot_dat)


## 4 clusters
ggsurv4
radar_plot_dat <- rbind(radar_plot_average_all, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_4")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

create_radar_plot(radar_plot_dat)

```



\clearpage

## Stratum k-Prototypes

### k-proto 2 centroids

```{r tableone-strat-kproto2, echo=FALSE}
t.kproto2 <- CreateTableOne(data=surv.dat1 %>% select(-1,   # "V_rapID" 
                                              -c(55:59),  # clusters
                                              -c(61:69),  # other clusters and outcomes until overall mortality
                                              -c(71:82)), # all other outcomes
                     strata = "clusters_kprototype2", 
                     #vars = colnames(surv.dat)[-c(4,5,15,16)],
                     factorVars = fctrs1)
tableone::kableone(t.kproto2, test=TRUE) %>% 
  pack_rows(group_label = "Number of Patients", start_row = 1, end_row = 1) %>% 
  pack_rows(group_label = "Demographics", start_row = 2, end_row = 3) %>% 
  pack_rows(group_label = "History and Symptoms", start_row = 4, end_row = 33) %>% 
  pack_rows(group_label = "Echo and Vital Signs", start_row = 34, end_row = 44) %>% 
  pack_rows(group_label = "ECG", start_row = 45, end_row = 51) %>% 
  pack_rows(group_label = "Lab", start_row = 52, end_row = 73) %>% 
  pack_rows(group_label = "Clusters", start_row = 74, end_row = 74) %>% 
  pack_rows(group_label = "Primary Outcome", start_row = 75, end_row = 75) %>% 
  kable_classic(full_width = T)
```

### k-proto 3 centroids

```{r tableone-strat-kproto3, echo=FALSE}
t.kproto3 <- CreateTableOne(data=surv.dat1 %>% select(-1,   # "V_rapID" 
                                              -c(55:60),  # clusters
                                              -c(62:69),  # other clusters and outcomes until overall mortality
                                              -c(71:82)), # all other outcomes
                     strata = "clusters_kprototype3", 
                     #vars = colnames(surv.dat)[-c(4,5,15,16)],
                     factorVars = fctrs1)
tableone::kableone(t.kproto3, test=TRUE) %>% 
  pack_rows(group_label = "Number of Patients", start_row = 1, end_row = 1) %>% 
  pack_rows(group_label = "Demographics", start_row = 2, end_row = 3) %>% 
  pack_rows(group_label = "History and Symptoms", start_row = 4, end_row = 33) %>% 
  pack_rows(group_label = "Echo and Vital Signs", start_row = 34, end_row = 44) %>% 
  pack_rows(group_label = "ECG", start_row = 45, end_row = 51) %>% 
  pack_rows(group_label = "Lab", start_row = 52, end_row = 73) %>% 
  pack_rows(group_label = "Clusters", start_row = 74, end_row = 77) %>% 
  pack_rows(group_label = "Primary Outcome", start_row = 78, end_row = 78) %>% 
  kable_classic(full_width = T)
```

### k-proto 4 centroids

```{r tableone-strat-kproto4, echo=FALSE}
t.kproto4 <- CreateTableOne(data=surv.dat1 %>% select(-1,   # "V_rapID" 
                                              -c(55:61),  # clusters
                                              -c(63:69),  # other clusters and outcomes until overall mortality
                                              -c(71:82)), # all other outcomes
                     strata = "clusters_kprototype4", 
                     #vars = colnames(surv.dat)[-c(4,5,15,16)],
                     factorVars = fctrs1)
tableone::kableone(t.kproto4, test=TRUE)  %>% 
  pack_rows(group_label = "Number of Patients", start_row = 1, end_row = 1) %>% 
  pack_rows(group_label = "Demographics", start_row = 2, end_row = 3) %>% 
  pack_rows(group_label = "History and Symptoms", start_row = 4, end_row = 33) %>% 
  pack_rows(group_label = "Echo and Vital Signs", start_row = 34, end_row = 44) %>% 
  pack_rows(group_label = "ECG", start_row = 45, end_row = 51) %>% 
  pack_rows(group_label = "Lab", start_row = 52, end_row = 73) %>% 
  pack_rows(group_label = "Clusters", start_row = 74, end_row = 78) %>% 
  pack_rows(group_label = "Primary Outcome", start_row = 79, end_row = 79) %>% 
  kable_classic(full_width = T)
```


### KM curves

```{r surv-analysis-plot-kproto, figures-side, fig.show='hold', out.width="100%", warning=FALSE, message=FALSE}
## surv curves

ggsurv2.kproto <- ggsurvplot_custom(fit_object = survfit(Surv(V_o_time_mortality, V_o_mortality)~clusters_kprototype2, data = surv.dat.km), mytitle = "Cluster Analysis - 2 unsupervised clusters", legend.title = "Clusters", myXbreaks = c(1,2), legend.labs = c("Cluster 1", "Cluster 2"), plot_inlay = TRUE,  save=FALSE)

ggsurv3.kproto <- ggsurvplot_custom(fit_object = survfit(Surv(V_o_time_mortality, V_o_mortality)~clusters_kprototype3, data = surv.dat.km), mytitle = "Cluster Analysis - 3 unsupervised clusters", legend.title = "Clusters", myXbreaks = c(1,2), legend.labs = c("Cluster 1", "Cluster 2", "Cluster 3" ), plot_inlay = TRUE,  save=FALSE)

ggsurv4.kproto <- ggsurvplot_custom(fit_object = survfit(Surv(V_o_time_mortality, V_o_mortality)~clusters_kprototype4, data = surv.dat.km), mytitle = "Cluster Analysis - 4 unsupervised clusters", legend.title = "Clusters", myXbreaks = c(1,2), legend.labs = c("Cluster 1", "Cluster 2", "Cluster 3", "Cluster 4" ), plot_inlay = TRUE,  save=FALSE)

# ggsurv2.kproto
# ggsurv3.kproto
# ggsurv4.kproto
```

```{r surv-analysis-plot-kproto-with-radar, figures-side, fig.show='hold', out.width="100%", warning=FALSE, message=FALSE}
# Function and Test in Chapter k-means 2 centroids

## 2 clusters
ggsurv2.kproto
radar_plot_dat <- rbind(radar_plot_average_all, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_kprototype2")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

create_radar_plot(radar_plot_dat)


## 3 clusters
ggsurv3.kproto
radar_plot_dat <- rbind(radar_plot_average_all, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_kprototype3")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

create_radar_plot(radar_plot_dat)


## 4 clusters
ggsurv4.kproto
radar_plot_dat <- rbind(radar_plot_average_all, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_kprototype4")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

create_radar_plot(radar_plot_dat)

```


## Stratum DBSCAN

### DBSCAN best hyperparameters

```{r tableone-strat-dbscan, echo=FALSE}
t.dbscan <- CreateTableOne(data=surv.dat1 %>% select(-1,   # "V_rapID" 
                                              -c(55:64),  # clusters
                                              -c(66:69),  # other clusters and outcomes until overall mortality
                                              -c(71:82)), # all other outcomes
                     strata = "clusters_dbscan", 
                     #vars = colnames(surv.dat)[-c(4,5,15,16)],
                     factorVars = fctrs1)
tableone::kableone(t.dbscan, test=TRUE)  %>% 
  pack_rows(group_label = "Number of Patients", start_row = 1, end_row = 1) %>% 
  pack_rows(group_label = "Demographics", start_row = 2, end_row = 3) %>% 
  pack_rows(group_label = "History and Symptoms", start_row = 4, end_row = 33) %>% 
  pack_rows(group_label = "Echo and Vital Signs", start_row = 34, end_row = 44) %>% 
  pack_rows(group_label = "ECG", start_row = 45, end_row = 51) %>% 
  pack_rows(group_label = "Lab", start_row = 52, end_row = 73) %>% 
  pack_rows(group_label = "Clusters", start_row = 74, end_row = 74) %>% 
  pack_rows(group_label = "Primary Outcome", start_row = 75, end_row = 75) %>% 
  kable_classic(full_width = T)
```

### KM curve

```{r surv-analysis-plot-dbscan, figures-side, fig.show='hold', out.width="100%", warning=FALSE, message=FALSE}
## surv curves
ggsurv2.dbscan <- ggsurvplot_custom(fit_object = survfit(Surv(V_o_time_mortality, V_o_mortality)~clusters_dbscan, data = surv.dat.km), mytitle = "Cluster Analysis - DBSCAN", legend.title = "Clusters", myXbreaks = c(1,2), legend.labs = c("Cluster 1", "Cluster 2"), plot_inlay = TRUE,  save=FALSE)


```


```{r surv-analysis-plot-dbscan-with-radar, figures-side, fig.show='hold', out.width="100%", warning=FALSE, message=FALSE}
# Function and Test in Chapter k-means 2 centroids
ggsurv2.dbscan
## 2 clusters
radar_plot_dat <- rbind(radar_plot_average_all, prepare_radar_plot_dat(data = surv.dat1, cluster_var = "clusters_dbscan")) %>% as.data.frame()
rownames(radar_plot_dat) <- radar_plot_dat$Row_index
radar_plot_dat <- radar_plot_dat %>% select(-Row_index)

create_radar_plot(radar_plot_dat)

```
